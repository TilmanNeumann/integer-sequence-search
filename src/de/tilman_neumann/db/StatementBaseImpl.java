/*
 * integer-sequence-search (ISS) is an offline OEIS sequence search engine.
 * Copyright (C) 2018 Tilman Neumann (www.tilman-neumann.de)
 *
 * This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this program;
 * if not, see <http://www.gnu.org/licenses/>.
 */
package de.tilman_neumann.db;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.List;

import org.apache.log4j.Logger;

import de.tilman_neumann.db.sql.SqlColumn;
import de.tilman_neumann.db.sql.SqlStringWithParams;
import de.tilman_neumann.db.statement.ResultSetIterator;

/**
 * Base class for SQL statements.
 * @author Tilman Neumann
 */
// This class should be in the same package as class Db to allow keeping the visibility of 
// critical members like Db.connection less than public.
public class StatementBaseImpl {
	
	private static final Logger LOG = Logger.getLogger(StatementBaseImpl.class);
	
	private Db db = null;
	protected PreparedStatement preparedStatement = null;
	protected SqlStringWithParams sqlStringAndParams = null;
	
	/** ResultSet generated by select statements. */
	protected ResultSetIterator resultSetItr = null;

	/**
	 * Standard constructor.
	 * @param db The database that wants to execute this statement
	 */
	public StatementBaseImpl(Db db) {
		this.db = db;
	}
	
	/**
	 * @return line separator
	 */
	protected String getLineSeparator() {
		String lineSeparator = System.getProperty("line.separator");
		if (lineSeparator == null) {
			lineSeparator = "\n";
		}
		return lineSeparator;
	}
	
	/**
	 * @return the SQL command this statement has been prepared for.
	 */
	protected String getSqlString() {
		return (sqlStringAndParams!=null) ? sqlStringAndParams.getSqlString() : null;
	}
	
	protected List<Object> getParams() {
		return (sqlStringAndParams!=null) ? sqlStringAndParams.getValues() : null;
	}
	
	public String toString() {
		return this.getSqlString() + ", values = " + this.getParams();
	}

	protected void prepareExecution() throws SQLException {
		// close last resultset whenever there is one because there can only be one,
		// even if the statement is going to be reused
		StatementBaseImpl lastStatement = db.lastStatement;
		if (lastStatement!=null) {
			lastStatement.closeResultSet();
		}
		// prepareStatement an set values
		this.prepare();
		this.setValues();
		// remember this as the statement to close or reuse in the future
		db.lastStatement = this;
	}

	/**
	 * Prepare the given SQL statement. This method must be called at the end of statement
	 * constructors. Afterwards we needs to set values for the place holders, and then the
	 * statement can be executed.
	 * @throws SQLException
	 */
	private void prepare() throws SQLException {
		
		String newSqlStr = sqlStringAndParams.getSqlString();
		StatementBaseImpl lastStatement = db.lastStatement;
		
		// Statement may be reused if there exists one and if its SQL string
		// is exactly the one that we want to apply now...
		boolean reuse = false;
		if (lastStatement != null) {
			String lastSql = lastStatement.getSqlString();
			if (lastSql.equals(newSqlStr)) {
				reuse = true;
			}
		}
		
		if (reuse) {
			// keep last statement, just reinitialize parameters
			this.preparedStatement = lastStatement.preparedStatement;
			this.preparedStatement.clearParameters();
		} else {
			// reuse not possible
			if (lastStatement != null) {
				// close last statement and result sets, notify StatementManager
				lastStatement.close();
			}
	    	// let statement manager prepare new statement
	    	this.preparedStatement = db.connection.prepareStatement(sqlStringAndParams.getSqlString());
		}
	}

	/**
	 * Sets the values of the place holders in the prepared statement.
	 * Afterwards the statement can be executed.
	 * 
	 * @throws SQLException
	 */
	private void setValues() throws SQLException {
		List<Object> values = sqlStringAndParams.getValues();
		//String sqlStr = sqlStringAndParams.getSqlString();
		//LOG.debug("setValues for SQL command >>" + sqlStr + "<<:");
		if (values!=null && values.size() > 0) {
			// set values in prepared statement:
	        int parIdx = 1; // index of next parameter & value
	        for (Object value : values) {
//	        	LOG.debug(value.getClass() + " " + value);
// assume nullability
//	            if (value != null) {
//	        		try {
	        			//LOG.debug("value " + parIdx + " = " + value);
	        			// TODO: Which solution works better?
	        			this.preparedStatement.setObject(parIdx, value);
//	            		this.preparedStatement.setString(parIdx, value.toString());
//	        		} catch(Exception e) {
//	        			LOG.debug("setObject threw " + e.getMessage(), e);
//	        		}
//	            } else {
//	            	// set null (or empty if null is not allowed)
//	            	if (column.IsNullable()) {
//	            		preparedStatement.setNull(parIdx, columnType);
//	            	} else {
//	            		preparedStatement.setObject(parIdx, "");
//	            	}
//	            }
	        	parIdx++; // next parameter & value
	        }
		}
	}
    
    /**
     * Returns the serial id of the last inserted row of the given table/column.
     * @param column
     * @return
     * @throws SQLException
     */
    // TODO: This works for PostgreSQL. Implement for other...
    public static int getLastInsertId(Db db, SqlColumn column) throws SQLException {
		Statement simpleStat = db.connection.createStatement();
        ResultSet rs = simpleStat.executeQuery("SELECT currval('" + column.getTableName() + "_" + column.getColumnName() + "_seq') As nextid");
        rs.next();
        int seq_id = rs.getInt(1);
        rs.close();
        simpleStat.close();
        return seq_id;
    }

	/**
	 * Close result set if exists.
	 * @throws SQLException 
	 */
	public void closeResultSet() throws SQLException {
		if (this.resultSetItr != null) {
			this.resultSetItr.close();
			this.resultSetItr = null;
		}
	}

	/**
	 * Close statement when not required anymore.
	 * Important to avoid memory lacks on the database server.
	 * @throws SQLException
	 */
	public void close() throws SQLException {
		// close ResultSet if exists
		this.closeResultSet();

		// close prepared statement if exists
		if (this.preparedStatement!=null) {
			this.preparedStatement.close();
			this.preparedStatement = null;
		}
	}
    
	/**
	 * Close statement and result set on exit.
	 */
	public void finalize() {
		try {
			this.close();
		} catch (SQLException e) {
			LOG.error(this + ".finalize(): " + e.getMessage(), e);
		}
	}
}
